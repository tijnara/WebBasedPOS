import { useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '../lib/supabaseClient';

export function useCreateSale() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: async (salePayload) => {
            console.log('useCreateSale: Starting sale transaction with payload:', salePayload);

            // 1. Create the main 'sales' entry first.
            // We insert an empty object (or payload fields if 'sales' table had them)
            // and immediately select the 'id' of the new row.
            // NOTE: Your 'sales' table schema only has 'id'. You should add
            // columns like totalAmount, customerId, paymentMethod, etc., to the 'sales' table.
            // For now, this will just create a sales entry to get an ID.
            const saleDataToInsert = {
                // id is auto-generated, but your schema says (id bigint not null)
                // This implies you might need to generate an ID or fix the schema
                // Let's assume 'id' is 'generated by default as identity'
                // If not, this query will fail.
                //
                // Let's assume your sales table *should* look like this:
                // id, created_at, customerId, customerName, totalAmount, paymentMethod, etc.
                totalAmount: salePayload.totalAmount,
                customerId: salePayload.customerId,
                customerName: salePayload.customerName,
                paymentMethod: salePayload.paymentMethod,
                amountReceived: salePayload.amountReceived,
                changeGiven: salePayload.changeGiven,
                status: salePayload.status,
                saleTimestamp: salePayload.saleTimestamp,
            };

            const { data: saleData, error: saleError } = await supabase
                .from('sales')
                .insert(saleDataToInsert) // Insert the main sale data
                .select('id')             // Get the ID of the new sale
                .single();

            if (saleError) {
                console.error('useCreateSale: Error creating sale entry:', saleError);
                throw new Error(`Failed to create sale: ${saleError.message}`);
            }

            const newSaleId = saleData.id;
            console.log('useCreateSale: Sale entry created with ID:', newSaleId);

            // 2. Prepare the 'sale_items' records.
            const itemsToInsert = salePayload.items.map(item => ({
                // 'id' for sale_items should also be auto-generated.
                // If not, this will fail.
                saleid: newSaleId,
                productid: item.productId,
                productname: item.productName,
                quantity: item.quantity,
                priceatsale: item.priceAtSale,
                subtotal: item.subtotal
            }));

            if (itemsToInsert.length === 0) {
                console.warn("useCreateSale: Sale created, but no items were included.");
                return saleData; // Return the main sale data
            }

            // 3. Insert all 'sale_items' in one go.
            console.log('useCreateSale: Inserting sale items:', itemsToInsert);
            const { error: itemsError } = await supabase
                .from('sale_items')
                .insert(itemsToInsert); // Insert the array of items

            if (itemsError) {
                // This is tricky. The 'sale' was created, but 'items' failed.
                // Ideally, you'd wrap this in a database transaction (RPC function)
                // to roll back the sale if items fail.
                // For now, we'll just log the error.
                console.error('useCreateSale: Error inserting sale items:', itemsError);
                throw new Error(`Sale created, but failed to save items: ${itemsError.message}`);
            }

            console.log('useCreateSale: Sale and items created successfully.');
            // Return the original sale data (or the newly created sale object)
            return { ...saleData, items: itemsToInsert }; // Return the full sale object
        },

        // 2. After the mutation succeeds
        onSuccess: (data) => {
            console.log('useCreateSale: Sale created! Invalidating queries.', data);
            // Invalidate both 'sales' and 'products' (for stock updates if you add them)
            queryClient.invalidateQueries({ queryKey: ['sales'] });
            queryClient.invalidateQueries({ queryKey: ['products'] });
        },
        onError: (error) => {
            console.error('useCreateSale: Mutation failed:', error);
        }
    });
}